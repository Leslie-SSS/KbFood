package platform

import (
	"context"
	"time"

	"kbfood/internal/config"
	"kbfood/internal/domain/entity"
)

// DTClient implements the DT platform client (push mode)
type DTClient struct {
	cfg *config.DTConfig
}

// NewDTClient creates a new DT client
func NewDTClient(cfg *config.DTConfig) *DTClient {
	return &DTClient{cfg: cfg}
}

// Name returns the platform name
func (c *DTClient) Name() string {
	return "DT"
}

// ShouldFetch is not applicable for DT (push mode)
func (c *DTClient) ShouldFetch(now time.Time) bool {
	return false
}

// FetchProducts is not implemented for DT (push mode)
func (c *DTClient) FetchProducts(ctx context.Context, region string) ([]*entity.PlatformProductDTO, error) {
	return nil, nil
}

// ProcessPushData processes pushed data from DT platform
func (c *DTClient) ProcessPushData(ctx context.Context, data []*PushData) (map[string][]*entity.PlatformProductDTO, error) {
	result := make(map[string][]*entity.PlatformProductDTO)

	for _, item := range data {
		if item.Region == "" {
			continue
		}

		dto := &entity.PlatformProductDTO{
			ActivityID:         "", // Will be generated by cleaner
			Platform:           c.Name(),
			Region:             item.Region,
			Title:              item.Title,
			ShopName:           "DT生活精选",
			OriginalPrice:      item.OriginalPrice,
			CurrentPrice:       item.Price,
			SalesStatus:        item.Status,
			ActivityCreateTime: time.Unix(item.CrawlTime, 0),
		}

		result[item.Region] = append(result[item.Region], dto)
	}

	return result, nil
}

// ValidateToken checks if the token is valid
func (c *DTClient) ValidateToken() bool {
	return c.cfg.Token != ""
}
