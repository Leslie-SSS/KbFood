// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notification.sql

package db

import (
	"context"
	"database/sql"
)

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notification_config WHERE activity_id = ? AND user_id = ?
`

type DeleteNotificationParams struct {
	ActivityID string `json:"activity_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.ExecContext(ctx, deleteNotification, arg.ActivityID, arg.UserID)
	return err
}

const getNotification = `-- name: GetNotification :one
SELECT activity_id, user_id, target_price, last_notify_time, create_time, update_time FROM notification_config
WHERE activity_id = ? AND user_id = ?
`

type GetNotificationParams struct {
	ActivityID string `json:"activity_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) (NotificationConfig, error) {
	row := q.db.QueryRowContext(ctx, getNotification, arg.ActivityID, arg.UserID)
	var i NotificationConfig
	err := row.Scan(
		&i.ActivityID,
		&i.UserID,
		&i.TargetPrice,
		&i.LastNotifyTime,
		&i.CreateTime,
		&i.UpdateTime,
	)
	return i, err
}

const listAllNotifications = `-- name: ListAllNotifications :many
SELECT activity_id, user_id, target_price, last_notify_time, create_time, update_time FROM notification_config
`

func (q *Queries) ListAllNotifications(ctx context.Context) ([]NotificationConfig, error) {
	rows, err := q.db.QueryContext(ctx, listAllNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationConfig{}
	for rows.Next() {
		var i NotificationConfig
		if err := rows.Scan(
			&i.ActivityID,
			&i.UserID,
			&i.TargetPrice,
			&i.LastNotifyTime,
			&i.CreateTime,
			&i.UpdateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsByUser = `-- name: ListNotificationsByUser :many
SELECT activity_id, user_id, target_price, last_notify_time, create_time, update_time FROM notification_config WHERE user_id = ?
`

func (q *Queries) ListNotificationsByUser(ctx context.Context, userID string) ([]NotificationConfig, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationConfig{}
	for rows.Next() {
		var i NotificationConfig
		if err := rows.Scan(
			&i.ActivityID,
			&i.UserID,
			&i.TargetPrice,
			&i.LastNotifyTime,
			&i.CreateTime,
			&i.UpdateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNotificationNotifyTime = `-- name: UpdateNotificationNotifyTime :exec
UPDATE notification_config
SET last_notify_time = datetime('now'),
    update_time = datetime('now')
WHERE activity_id = ? AND user_id = ?
`

type UpdateNotificationNotifyTimeParams struct {
	ActivityID string `json:"activity_id"`
	UserID     string `json:"user_id"`
}

func (q *Queries) UpdateNotificationNotifyTime(ctx context.Context, arg UpdateNotificationNotifyTimeParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationNotifyTime, arg.ActivityID, arg.UserID)
	return err
}

const upsertNotification = `-- name: UpsertNotification :exec
INSERT INTO notification_config (activity_id, user_id, target_price, last_notify_time)
VALUES (?, ?, ?, ?)
ON CONFLICT (activity_id, user_id) DO UPDATE
SET target_price = excluded.target_price,
    last_notify_time = excluded.last_notify_time,
    update_time = datetime('now')
`

type UpsertNotificationParams struct {
	ActivityID     string         `json:"activity_id"`
	UserID         string         `json:"user_id"`
	TargetPrice    float64        `json:"target_price"`
	LastNotifyTime sql.NullString `json:"last_notify_time"`
}

func (q *Queries) UpsertNotification(ctx context.Context, arg UpsertNotificationParams) error {
	_, err := q.db.ExecContext(ctx, upsertNotification,
		arg.ActivityID,
		arg.UserID,
		arg.TargetPrice,
		arg.LastNotifyTime,
	)
	return err
}
